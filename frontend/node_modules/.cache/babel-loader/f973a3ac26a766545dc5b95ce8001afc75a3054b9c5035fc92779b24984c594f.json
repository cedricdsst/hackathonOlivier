{"ast":null,"code":"'use strict';\n\n/// <reference types=\"../types/index.d.ts\" />\n\n// (c) 2020-present Andrea Giammarchi\nrequire(\"core-js/modules/es.array.push.js\");\nconst {\n  parse: $parse,\n  stringify: $stringify\n} = JSON;\nconst {\n  keys\n} = Object;\nconst Primitive = String; // it could be Number\nconst primitive = 'string'; // it could be 'number'\n\nconst ignore = {};\nconst object = 'object';\nconst noop = (_, value) => value;\nconst primitives = value => value instanceof Primitive ? Primitive(value) : value;\nconst Primitives = (_, value) => typeof value === primitive ? new Primitive(value) : value;\nconst revive = (input, parsed, output, $) => {\n  const lazy = [];\n  for (let ke = keys(output), {\n      length\n    } = ke, y = 0; y < length; y++) {\n    const k = ke[y];\n    const value = output[k];\n    if (value instanceof Primitive) {\n      const tmp = input[value];\n      if (typeof tmp === object && !parsed.has(tmp)) {\n        parsed.add(tmp);\n        output[k] = ignore;\n        lazy.push({\n          k,\n          a: [input, parsed, tmp, $]\n        });\n      } else output[k] = $.call(output, k, tmp);\n    } else if (output[k] !== ignore) output[k] = $.call(output, k, value);\n  }\n  for (let {\n      length\n    } = lazy, i = 0; i < length; i++) {\n    const {\n      k,\n      a\n    } = lazy[i];\n    output[k] = $.call(output, k, revive.apply(null, a));\n  }\n  return output;\n};\nconst set = (known, input, value) => {\n  const index = Primitive(input.push(value) - 1);\n  known.set(value, index);\n  return index;\n};\n\n/**\r\n * Converts a specialized flatted string into a JS value.\r\n * @param {string} text\r\n * @param {((this: any, key: string, value: any) => any) | undefined): any} [reviver]\r\n * @returns {any}\r\n */\nconst parse = (text, reviver) => {\n  const input = $parse(text, Primitives).map(primitives);\n  const value = input[0];\n  const $ = reviver || noop;\n  const tmp = typeof value === object && value ? revive(input, new Set(), value, $) : value;\n  return $.call({\n    '': tmp\n  }, '', tmp);\n};\nexports.parse = parse;\n\n/**\r\n * Converts a JS value into a specialized flatted string.\r\n * @param {any} value\r\n * @param {((this: any, key: string, value: any) => any) | (string | number)[] | null | undefined} [replacer]\r\n * @param {string | number | undefined} [space]\r\n * @returns {string}\r\n */\nconst stringify = (value, replacer, space) => {\n  const $ = replacer && typeof replacer === object ? (k, v) => k === '' || -1 < replacer.indexOf(k) ? v : void 0 : replacer || noop;\n  const known = new Map();\n  const input = [];\n  const output = [];\n  let i = +set(known, input, $.call({\n    '': value\n  }, '', value));\n  let firstRun = !i;\n  while (i < input.length) {\n    firstRun = true;\n    output[i] = $stringify(input[i++], replace, space);\n  }\n  return '[' + output.join(',') + ']';\n  function replace(key, value) {\n    if (firstRun) {\n      firstRun = !firstRun;\n      return value;\n    }\n    const after = $.call(this, key, value);\n    switch (typeof after) {\n      case object:\n        if (after === null) return after;\n      case primitive:\n        return known.get(after) || set(known, input, after);\n    }\n    return after;\n  }\n};\nexports.stringify = stringify;\n\n/**\r\n * Converts a generic value into a JSON serializable object without losing recursion.\r\n * @param {any} value\r\n * @returns {any}\r\n */\nconst toJSON = value => $parse(stringify(value));\nexports.toJSON = toJSON;\n\n/**\r\n * Converts a previously serialized object with recursion into a recursive one.\r\n * @param {any} value\r\n * @returns {any}\r\n */\nconst fromJSON = value => parse($stringify(value));\nexports.fromJSON = fromJSON;","map":{"version":3,"names":["require","parse","$parse","stringify","$stringify","JSON","keys","Object","Primitive","String","primitive","ignore","object","noop","_","value","primitives","Primitives","revive","input","parsed","output","$","lazy","ke","length","y","k","tmp","has","add","push","a","call","i","apply","set","known","index","text","reviver","map","Set","exports","replacer","space","v","indexOf","Map","firstRun","replace","join","key","after","get","toJSON","fromJSON"],"sources":["C:/Users/cedric/Desktop/coursNodeJs/chokbar/frontend/node_modules/flatted/cjs/index.js"],"sourcesContent":["'use strict';\r\n/// <reference types=\"../types/index.d.ts\" />\r\n\r\n// (c) 2020-present Andrea Giammarchi\r\n\r\nconst {parse: $parse, stringify: $stringify} = JSON;\r\nconst {keys} = Object;\r\n\r\nconst Primitive = String;   // it could be Number\r\nconst primitive = 'string'; // it could be 'number'\r\n\r\nconst ignore = {};\r\nconst object = 'object';\r\n\r\nconst noop = (_, value) => value;\r\n\r\nconst primitives = value => (\r\n  value instanceof Primitive ? Primitive(value) : value\r\n);\r\n\r\nconst Primitives = (_, value) => (\r\n  typeof value === primitive ? new Primitive(value) : value\r\n);\r\n\r\nconst revive = (input, parsed, output, $) => {\r\n  const lazy = [];\r\n  for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {\r\n    const k = ke[y];\r\n    const value = output[k];\r\n    if (value instanceof Primitive) {\r\n      const tmp = input[value];\r\n      if (typeof tmp === object && !parsed.has(tmp)) {\r\n        parsed.add(tmp);\r\n        output[k] = ignore;\r\n        lazy.push({k, a: [input, parsed, tmp, $]});\r\n      }\r\n      else\r\n        output[k] = $.call(output, k, tmp);\r\n    }\r\n    else if (output[k] !== ignore)\r\n      output[k] = $.call(output, k, value);\r\n  }\r\n  for (let {length} = lazy, i = 0; i < length; i++) {\r\n    const {k, a} = lazy[i];\r\n    output[k] = $.call(output, k, revive.apply(null, a));\r\n  }\r\n  return output;\r\n};\r\n\r\nconst set = (known, input, value) => {\r\n  const index = Primitive(input.push(value) - 1);\r\n  known.set(value, index);\r\n  return index;\r\n};\r\n\r\n/**\r\n * Converts a specialized flatted string into a JS value.\r\n * @param {string} text\r\n * @param {((this: any, key: string, value: any) => any) | undefined): any} [reviver]\r\n * @returns {any}\r\n */\r\nconst parse = (text, reviver) => {\r\n  const input = $parse(text, Primitives).map(primitives);\r\n  const value = input[0];\r\n  const $ = reviver || noop;\r\n  const tmp = typeof value === object && value ?\r\n              revive(input, new Set, value, $) :\r\n              value;\r\n  return $.call({'': tmp}, '', tmp);\r\n};\r\nexports.parse = parse;\r\n\r\n/**\r\n * Converts a JS value into a specialized flatted string.\r\n * @param {any} value\r\n * @param {((this: any, key: string, value: any) => any) | (string | number)[] | null | undefined} [replacer]\r\n * @param {string | number | undefined} [space]\r\n * @returns {string}\r\n */\r\nconst stringify = (value, replacer, space) => {\r\n  const $ = replacer && typeof replacer === object ?\r\n            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :\r\n            (replacer || noop);\r\n  const known = new Map;\r\n  const input = [];\r\n  const output = [];\r\n  let i = +set(known, input, $.call({'': value}, '', value));\r\n  let firstRun = !i;\r\n  while (i < input.length) {\r\n    firstRun = true;\r\n    output[i] = $stringify(input[i++], replace, space);\r\n  }\r\n  return '[' + output.join(',') + ']';\r\n  function replace(key, value) {\r\n    if (firstRun) {\r\n      firstRun = !firstRun;\r\n      return value;\r\n    }\r\n    const after = $.call(this, key, value);\r\n    switch (typeof after) {\r\n      case object:\r\n        if (after === null) return after;\r\n      case primitive:\r\n        return known.get(after) || set(known, input, after);\r\n    }\r\n    return after;\r\n  }\r\n};\r\nexports.stringify = stringify;\r\n\r\n/**\r\n * Converts a generic value into a JSON serializable object without losing recursion.\r\n * @param {any} value\r\n * @returns {any}\r\n */\r\nconst toJSON = value => $parse(stringify(value));\r\nexports.toJSON = toJSON;\r\n\r\n/**\r\n * Converts a previously serialized object with recursion into a recursive one.\r\n * @param {any} value\r\n * @returns {any}\r\n */\r\nconst fromJSON = value => parse($stringify(value));\r\nexports.fromJSON = fromJSON;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}